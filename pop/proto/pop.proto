syntax = "proto3";

package vim_pop;

option go_package = "proto";

import "empty.proto";

// Service definition.
service Pop {
  // Listing functions

  // Containers returns the containers available in the PoP, either 
  // created or running.
  rpc Containers(Filter) returns (ContainerList);

  // Flavours returns the available flavours.
  // This doesn't make much sense with containers, but it's here to 
  // better abstract the PoP.
  rpc Flavours(Filter) returns (FlavourList);

  // Images returns the images available in the PoP.
  rpc Images(Filter) returns (ImageList);

  // Networks returns the available retworks in the PoP.
  rpc Networks(Filter) returns (NetworkList);

  // container functions

  // Create creates a new container as described.
  rpc Create(ContainerConfig) returns (Container);

  // Delete stops and deletes the container identified by the given filter.
  rpc Delete(Filter) returns (google.protobuf.Empty);

  // Metadata adds the given metadata values to the container that matches with the ID.
  // An empty value for a key means that the key will be removed from the metadata.
  rpc Metadata(NewMetadata) returns (google.protobuf.Empty);

  // Start starts the container identified by the given filter.
  // Any metadata key stored in the server will be passed to the newly instantiated container.
  rpc Start(Filter) returns (Container);

  // Stop starts the container identified by the given filter.
  rpc Stop(Filter) returns (google.protobuf.Empty);

  // login/logout functions

  // Login logs an user in and sets up a session.
  // The returned token should be set into the metadata 
  // of the gRPC session with key "token" to authenticate your client.
  rpc Login(Credentials) returns (Token);

  // Logout invalids the current token.
  rpc Logout(google.protobuf.Empty) returns (google.protobuf.Empty); 

  // other functions

  // Info can be used to check if the Pop is alive and if your credentials to this service are valid.
  // It also returns informations about this server.
  rpc Info(google.protobuf.Empty) returns (Infos);
}

message Container {
  string id = 1;
  repeated string names = 2;
  string image_id = 3;
  string flavour_id = 4;
  string command = 5;
  int64 created = 6;
  int64 started = 7;

  enum Status {
    UNAVAILABLE = 0;
    CREATED  = 1;
    RUNNING  = 2;
    EXITED   = 3;
    FAILED   = 4;
    STOPPING = 5;
  }

  Status status = 8;
  string extended_status = 9;
  map<string, Endpoint> endpoints = 10;
  Metadata md = 11;
}

message ContainerConfig {
  string name = 1;
  string image_id = 2;
  string flavour_id = 3;
  map<string, Endpoint> endpoints = 4;
}

message ContainerList {
  repeated Container list = 1;
}

// Credentials represents the login credentials for a given user.
message Credentials {
  string username = 1;
  string password = 2;
}

message Endpoint {
  string net_id = 1;
  string net_name = 2;
  string endpoint_id = 3;
  Ip ipv4 = 4;
  Ip ipv6 = 5;
  string mac = 6;
}

// Filter is used to specify a filter that matches a container.
message Filter {
  oneof options {
    string id = 1;
    string name = 2;
  }
}

message Flavour {
  string id = 1;
  string name = 2;
}

message FlavourList {
  repeated Flavour list = 1;
}

message Image {
  string id = 1;
  repeated string names = 2;
  int64 created = 3;
}

message ImageList {
  repeated Image list = 1;
}

message Infos {
  string type = 1;
  string name = 2;
  int64 timestamp = 3;
}

message Ip {
  string address = 1;
  Subnet subnet = 2;
}

// Metadata contains a key-value set of metadata
// pairs, that will be exposed to the underlying container.
message Metadata {
  map<string, string> entries = 1;
}

message Network {
  string id = 1;
  string name = 2;
  bool external = 3;
  repeated Subnet subnets = 4;
}

message NetworkList {
  repeated Network list = 1;
}

message NewMetadata {
  Filter filter = 1;
  Metadata md = 2;
}

message Subnet {
  string cidr = 1;
  string gateway = 2; 
}

// Token is a token generated by the server after a successful login.
// This token should be set as metadata, to authenticate every other 
message Token {
  string value = 1;
}


